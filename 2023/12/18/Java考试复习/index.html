<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java考试复习 | HK的个人博客</title><meta name="author" content="HK"><meta name="copyright" content="HK"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java考试复习"><meta name="application-name" content="Java考试复习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java考试复习"><meta property="og:url" content="http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/index.html"><meta property="og:site_name" content="HK的个人博客"><meta property="og:description" content="1. 标识符（Identifiers）标识符是在编程语言中，用于识别类、变量、方法等实体的名称。在Java中，标识符遵循以下规则：  字符组成：可以包含字母、数字、下划线(_)和美元符号($)。 开头：标识符不能以数字开始。 保留字：不能使用Java的关键字（如 int, class, static"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="HK"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1. 标识符（Identifiers）标识符是在编程语言中，用于识别类、变量、方法等实体的名称。在Java中，标识符遵循以下规则：  字符组成：可以包含字母、数字、下划线(_)和美元符号($)。 开头：标识符不能以数字开始。 保留字：不能使用Java的关键字（如 int, class, static"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: HK","link":"链接: ","source":"来源: HK的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'HK的个人博客',
  title: 'Java考试复习',
  postAI: '',
  pageFillDescription: '1. 标识符（Identifiers）, 2. 注释（Comments）, 3. TCP编程, 4. 线程（Threads）, 1. List, 2. Set, 3. Map, 1. ampamp（逻辑与）, 2. amp（按位与 / 非短路逻辑与）, 总结, 实现单例模式的关键要素：, 实现单例的几种方式：, 1. 懒汉式（延迟实例化）, 懒汉式（Lazy Initialization）, 2. 饿汉式（立即实例化）, 饿汉式（Eager Initialization）, 3. 双重检查锁定（Double-Checked Locking）, 双重检查锁定（Double-Checked Locking）, 4. 静态内部类（Static Nested Class）, 静态内部类（Static Nested Class）, 5. 枚举方式（Enum Singleton）, 枚举方式（Enum Singleton）, 总结, 重载（Overloading）, 重写（Overriding）, 总结, 抽象类（Abstract Class）, 接口（Interface）, 总结, 成员变量与局部变量, 使用 this 关键字, 例子, 字节流（Byte Streams）, 字符流（Character Streams）, 总结, 什么是对象序列化, 如何实现序列化, 示例代码：序列化和反序列化, 注意事项, 冒泡排序, 其他常见排序算法, 选择排序：, 插入排序：, 快速排序：, 归并排序：, 堆排序：, 接口 - 定义功能, 抽象类 - 提供基本实现, 具体实现, 使用标识符标识符是在编程语言中用于识别类变量方法等实体的名称在中标识符遵循以下规则字符组成可以包含字母数字下划线和美元符号开头标识符不能以数字开始保留字不能使用的关键字如等作为标识符大小写敏感中的标识符是大小写敏感的例如和被视为不同的标识符好的实践类名应该使用大写字母开头的驼峰式命名法如方法和变量名应该使用小写字母开头的驼峰式命名法如常量通常使用全大写字母单词间以下划线分隔如注释注释是解释代码意图和功能的非执行文本中有三种类型的注释单行注释使用这种注释只影响它后面的一行计算两数之和多行注释使用这种注释可以跨越多行这是一个多行注释可以用来解释代码的更多细节文档注释使用这种注释用于生成它可以描述类方法和字段等计算两个整数的乘积第一个整数第二个整数乘积编程是一种可靠的面向连接的网络协议中的编程主要涉及类和类在客户端用于建立网络连接发送和接收数据在服务器端用于监听客户端的连接请求客户端示例发送和接收数据服务器示例线程线程是程序中的执行流中的线程可以通过以下两种方式创建实现接口这是推荐的方式因为它允许你的类继承其他类继承类这种方式简单直接但限制了类的继承因为不支持多重继承实现接口继承类在多线程环境中同步和并发控制是关键提供了多种机制如关键字类类等来帮助管理线程之间的协调和通信集合框架中的和是三种不同类型的集合它们各自具有独特的特性和用途是一个有序集合可以包含重复的元素它是一个按照插入顺序排列元素的集合你可以通过索引来访问元素特点元素有序元素的添加顺序决定了它们的访问顺序允许重复的元素相同的元素可以出现多次索引访问可以通过索引来访问或修改列表中的元素常见实现提供快速的随机访问和高效的基于索引的操作性能不是线程安全的除了实现接口外还实现了接口使其可以作为队列或双端队列使用在列表的中间进行添加和删除操作时比更高效使用场景当需要频繁地通过索引访问元素时当需要保持元素的插入顺序时代码示例允许重复访问第二个元素是一个不包含重复元素的集合它主要用于测试某个值的存在性并确保集合中没有重复的元素特点不允许重复的元素添加相同元素时不会有任何效果不保证元素顺序大多数实现不保证元素的顺序甚至某些实现如会随着时间的推移改变元素的顺序常见实现基于哈希表实现提供快速的添加删除和查找操作不保证元素的顺序类似于但它维护了一个链表来记录插入顺序基于红黑树实现元素按照其自然顺序或者提供的比较器进行排序使用场景当需要确保集合中不出现重复元素时当元素的顺序不重要或者需要根据某种排序规则来维持元素的顺序时代码示例重复元素不会被添加顺序可能与添加顺序不同是一种键值对的集合它通过键来唯一标识元素每个键映射到一个值特点键值对每个元素都是一个键值对唯一的键键不允许重复但值可以重复不是接口的一部分与和不同它不是接口的一部分常见实现基于哈希表的实现提供快速的访问和插入操作不保证顺序类似于但维护了插入顺序或访问顺序基于红黑树的实现按照键的自然顺序或者提供的比较器进行排序使用场景当需要通过键来快速检索数据时当需要将值与唯一键相关联时代码示例替换旧值通过键访问总结来说用于维护有序的元素集合用于存储不重复的元素集合而用于存储键值对其中键是唯一的选择哪种类型取决于具体的应用场景和需求逻辑与是逻辑与运算符用于组合两个布尔表达式它只有在两个布尔表达式都为时才返回短路特性这是最关键的特性如果第一个表达式的结果是则整个表达式立即返回而不再评估第二个表达式这个特性在编程中非常有用尤其是当第二个表达式依赖于第一个表达式的结果时代码示例及结果第一个表达式为输出第二个表达式没有被评估在这个例子中由于为不会被评估整个表达式的结果直接为按位与非短路逻辑与既可以作为按位与运算符用于整数也可以作为非短路逻辑与运算符用于布尔值按位与当用于整数时对两个数的每一位进行逻辑与操作只有两个相应的位都为时结果位才为非短路逻辑与当用于布尔值时它类似于但它会评估两边的表达式即使第一个表达式为布尔逻辑的代码示例及结果为但仍然被评估输出在这个例子中尽管为仍然被评估但因为逻辑与操作要求两边都为所以最终结果是按位与的代码示例及结果二进制二进制二进制即输出在这个例子中二进制和二进制进行按位与操作只有最右侧的位都为因此结果是二进制总结适用于布尔逻辑具有短路特性可以提高效率并防止不必要的计算或潜在的错误在处理整数时作为按位与运算符在处理布尔值时作为非短路逻辑与运算符在布尔逻辑中它会评估两边的表达式无论第一个表达式的结果如何单例设计模式是一种常用的设计模式它确保一个类只有一个实例并提供一个全局访问点来获取这个实例单例模式在中广泛用于配置管理线程池缓存等场景实现单例模式的关键要素私有构造函数防止通过操作符外部直接创建类的实例私有静态实例类的唯一实例应该是私有的和静态的公共静态方法提供一个公共的静态方法来获取这个唯一实例实现单例的几种方式懒汉式延迟实例化在此实现中实例是在首次需要时创建的这种方法是懒加载的懒汉式在懒汉式实现中单例实例在第一次被请求时创建这种实现延迟了实例的创建有助于节省资源和减少内存开销优点资源利用率高只有在实际需要时才创建实例在应用启动时减少初始化负担缺点在多线程环境下如果没有适当的同步措施可能会创建多个实例即使加上了同步每次访问方法时都需要进行同步这会增加访问开销这种实现的缺点是在多线程环境下可能会创建多个实例除非方法是同步的但这会降低性能饿汉式立即实例化在此实现中实例在类被加载时立即创建饿汉式实现简单但是它不是懒加载可能会增加内存的使用饿汉式在饿汉式实现中单例实例在类加载时立即创建保证静态变量会在类首次被加载到内存时初始化这利用了本身的机制保证了线程安全优点线程安全无需额外的同步措施实现简单缺点类加载时就创建实例即使客户端可能尚未用到它增加了内存开销没有实现懒加载可能导致资源利用效率低下双重检查锁定此方法结合了懒汉式和饿汉式的优点它在同步代码块内外都进行了检查以减少不必要的同步开销这种方式在多线程环境下既能保持高性能又能保证单例双重检查锁定这种实现在方法中两次检查实例是否已创建并且使用同步块这种方法既保证了懒加载又保证了线程安全同时减少了同步开销优点线程安全只有在实例未被创建时才进行同步一旦实例被创建就无需再进行同步减少了开销实现了懒加载缺点实现相对复杂在某些情况下可能会失效在某些编译器和处理器上静态内部类利用静态内部类的特性结合懒加载和线程安全的优点静态内部类的方式在类被加载时不会立即实例化而是在需要实例时调用方法从而完成实例化静态内部类这种方法利用了的类加载机制来保证实例的唯一性和线程安全静态内部类只有在被引用时才会被加载从而实现懒加载优点线程安全实现懒加载无需同步性能好缺点实现稍微复杂一些枚举方式这是实现单例的最佳方法之一它自动支持序列化机制并且由保证只会实例化一次方法实现通过来访问实例这种方法是线程安全的并且在多线程环境下它也保持单一实例枚举方式使用枚举来实现单例是最简洁的方式它自然地提供序列化机制并由保证只会实例化一次优点简单易懂线程安全提供序列化机制保证只实例化一次缺点不是懒加载但实际上由于枚举类的特性这通常不是问题总结选择哪种实现方式取决于应用的需求如果应用程序始终在创建和运行单例对象则可以选择饿汉式实现如果单例对象的创建和运行开销大且应用程序不一定需要单例对象则应选择懒汉式实现双重检查锁定和静态内部类方式提供了一种在需要时创建单例且保证线程安全的方式枚举方式提供了简洁和自动支持序列化的实现选择哪种单例实现取决于具体场景如果单例对象占用资源较少且确定会在应用中使用可以选择饿汉式如果资源利用是一个考虑因素并且对同步性能要求较高可以使用双重检查锁定或静态内部类如果希望实现简洁且需要序列化机制枚举方式是一个不错的选择在考虑实现时还需要考虑实例的创建是否会影响应用程序的启动时间以及资源的有效利用在中重载和重写是面向对象编程的两个基本概念它们虽然听起来相似但实际上在功能和用途上有很大的不同重载重载发生在同一个类中它指的是在一个类里面有多个同名方法但这些方法的参数列表不同参数列表必须不同重载的方法必须改变参数列表这可以是参数的数量不同参数的类型不同参数的顺序不同如果类型不同返回类型可以不同重载的方法可以有不同的返回类型但仅仅改变返回类型不足以构成重载访问修饰符和异常可以不同重载的方法可以有不同的访问修饰符和抛出的异常编译时的行为编译器根据方法签名方法名称加参数列表来决定调用哪个重载的方法代码示例参数数量不同参数类型不同参数数量和类型都不同在这个例子中方法被重载了三次每次都有不同的参数列表重写重写发生在父类和子类之间当子类有一个方法与父类的某个方法具有相同的名称和参数列表时子类的方法会重写或覆盖父类的方法方法名称和参数列表必须完全相同也就是说子类中的方法和父类中被重写的方法必须有相同的方法签名返回类型必须相同或是子类型从开始允许子类重写的方法返回父类方法返回类型的子类型访问级别不能更严格子类的方法不能有比父类方法更严格的访问级别抛出的异常应该相同或是异常的子类型如果有的话运行时决定哪个重写方法应该被调用是在运行时基于对象的实际类型决定的使用注解这个注解不是必需的但建议使用因为它可以帮助编译器检测到子类是否正确地重写了父类方法代码示例输出输出在这个例子中重写了中的方法当使用的实例调用方法时将执行重写后的版本总结重载主要关注于同一个类内部多个同名方法的参数不同是编译时的概念重写关注于子类如何具体实现或修改父类的某个方法是运行时的概念抽象类抽象类是一种特殊的类不能被直接实例化它通常被用作其他类的基类父类抽象类的主要特点和用途包括部分实现与抽象方法抽象类可以包含完全实现的方法具体方法和没有实现的方法抽象方法子类继承抽象类时必须实现所有的抽象方法除非它们也被声明为抽象类状态保持抽象类可以有成员变量用于保存状态信息这些成员变量可以是非静态的因此可以在对象实例中具有唯一的状态构造函数抽象类可以有构造函数尽管抽象类不能直接实例化这些构造函数可以被子类调用来初始化子类对象的共同属性或行为限制继承由于不支持多重类继承因此一个类只能继承一个抽象类这可以被视为既是一个优点有助于维持类的层次结构也是一个限制不如接口灵活代码示例抽象方法接口接口定义了一组方法这些方法可以被任何实现了该接口的类所实现接口的主要特点和用途包括全抽象的方法之前在之前接口只能有抽象方法没有方法体的方法这意味着实现接口的任何类都必须实现这些方法默认方法及之后引入了接口的默认方法这些方法有一个默认的实现这使得接口变得更加灵活因为不是所有实现该接口的类都必须实现这些方法多重实现一个类可以实现多个接口这提供了一种形式的多重继承这意味着类可以拥有多个不相关类的行为静态方法和常量接口可以包含静态方法和常量常量默认是的而静态方法可以有自己的实现无状态接口不能有实例变量它们可以有静态变量但这些变量必须是常量代码示例抽象方法默认方法总结抽象类用于创建一个含有一些实现和一些需要由子类实现的方法的类框架它适用于多个类共享一些共同的方法实现或属性时接口用于定义一个可以被多个类实现的契约接口更加灵活特别是在需要多重继承的功能特性时在实际应用中选择抽象类还是接口通常取决于你要设计的系统的具体需求随着的发展接口越来越强大提供了更多灵活性但抽象类仍然在某些特定情况下非常有用在中关键字是一个引用变量指向当前对象当你在一个方法或构造器内部使用你实际上是在引用当前对象的成员在这行代码中这个语句出现在类的构造函数中其作用是将传递给构造函数的参数的值赋值给类的成员变量这里需要使用关键字来区分成员变量和参数因为它们的名称是相同的让我更详细地解释一下成员变量与局部变量成员变量定义在类中的变量它们是对象的属性或状态的一部分在这个例子中是一个成员变量局部变量定义在方法构造器或代码块中的变量在这个例子中构造器的参数是一个局部变量使用关键字当一个局部变量如方法或构造器的参数和一个成员变量具有相同的名称时为了区分这两个变量我们使用关键字关键字引用的是当前对象它的成员变量在这个赋值语句中指的是当前对象的成员变量等号右边的指的是传递给构造器的参数例子成员变量构造器的参数也叫将成员变量设置为参数的值在这个例子中构造函数接收一个参数由于成员变量也被命名为因此使用来明确我们指的是成员变量而非参数这种做法在中非常普遍它清楚地表明了哪个是类的属性成员变量哪个是仅在构造器或方法中使用的局部变量或参数在中字符流和字节流是处理输入和输出的两种主要方式它们在处理数据时有着本质的区别字节流字节流主要用于处理原始二进制数据它们读写数据的基本单位是字节位因此非常适合处理所有类型的数据如图像视频音频二进制文件等基本类字节流的基本类是和用途字节流非常适合处理非文本文件如二进制文件和媒体文件操作方式在字节流中所有的数据都是按字节来处理的示例使用字节流读取文件处理读取的字节字符流字符流用于处理文本数据它们按字符读写数据一个字符可能占用一个或多个字节取决于字符编码字符流自动处理字符编码的转换过程这使得它们非常适合处理文本文件基本类字符流的基本类是和用途字符流主要用于处理文本数据由于它们处理字符编码因此特别适合处理多字节的字符集如操作方式字符流在内部自动处理字节到字符的转换当你从输入流读取数据时字符流自动将字节组装成字符当你写入数据时字符流将字符拆分成字节示例使用字符流读取文件处理读取的字符总结字节流是处理原始二进制数据的低级流适合所有类型的数据尤其是非文本数据字符流是处理字符数据的高级流自动处理字符编码问题适合处理文本数据在实际应用中选择字节流还是字符流取决于你要处理的数据类型如果你处理的是文本数据建议使用字符流如果处理的是二进制数据如图像或视频文件则应使用字节流对象序列化是编程中的一个核心概念涉及到将对象的状态转换成可以存储或传输的格式的过程在中这通常意味着将对象转换成字节流以便可以将其写入磁盘通过网络发送或在其他地方使用什么是对象序列化对象转换为字节流序列化是将对象的状态信息转换为可以存储或传输的形式如文件或内存缓冲区中的字节流的过程序列化后的数据可以在需要的时候被反序列化成原始对象数据存储和通信序列化使得对象的数据可以轻松地保存到文件中或在网络上传输并且稍后可以完整地重建对象如何实现序列化在中要实现对象的序列化通常需要做以下几步实现接口让一个类实现接口这个接口是一个标记接口没有方法需要实现它告诉虚拟机这个类的对象可以被序列化使用利用类将对象写入流中可以将对象转换为字节流反序列化使用类从流中重构对象这一过程称为反序列化示例代码序列化和反序列化一个简单的可序列化类使用关键字标记的字段不会被序列化创建对象序列化反序列化在这个例子中类实现了接口使得其对象可以被序列化和反序列化关键字用于指示不希望某个字段被序列化注意事项版本控制通过声明字段来控制序列化版本这有助于在反序列化时确保类版本的兼容性安全性对象序列化可能存在安全风险因为攻击者可能会修改序列化数据来攻击系统因此当处理不信任的数据时应该谨慎使用序列化性能序列化和反序列化过程涉及到复杂的转换可能会对性能有所影响尤其是在大对象或大量数据的情况下因此应该尽可能地减少序列化数据的体积和数量以提高性能冒泡排序是最基本的排序算法之一它的工作原理是通过重复地遍历要排序的数列一次比较两个元素如果它们的顺序错误就把它们交换过来遍历数列的工作是重复进行的直到没有再需要交换也就是说该数列已经排序完成冒泡排序算法步骤比较相邻的两个元素如果第一个比第二个大就交换它们两个对每一对相邻元素做同样的工作从开始第一对到结尾的最后一对完成一遍后最后的元素会是最大的数针对所有的元素重复以上的步骤除了最后一个重复步骤直到排序完成代码示例交换和其他常见排序算法选择排序原理首先在未排序序列中找到最小大元素存放到排序序列的起始位置然后再从剩余未排序元素中继续寻找最小大元素然后放到已排序序列的末尾性能时间复杂度为不稳定排序选择排序的基本思想是在每次迭代中找到最小或最大元素并将其放置到序列的起始位置代码示例交换找到的最小元素和第个元素插入排序原理通过构建有序序列对于未排序数据在已排序序列中从后向前扫描找到相应位置并插入性能时间复杂度为稳定排序插入排序工作方式是通过构建有序序列对于未排序数据在已排序序列中从后向前扫描找到相应位置并插入代码示例将大于的元素向后移动一个位置快速排序原理选择一个基准元素分区过程将其它所有元素分为两个分区将比基准值小的元素移到基准前大的移到后面性能平均时间复杂度为不稳定排序快速排序使用分治法策略来把一个序列分为较小和较大的两个子序列然后递归地排序两个子序列代码示例交换和交换和或递归地排序分区的元素归并排序原理采用分治法的一个非常典型的应用将已有序的子序列合并得到完全有序的序列即先使每个子序列有序再使子序列段间有序性能时间复杂度为稳定排序归并排序是一种分治算法它不断地将列表分成两半直到每个子列表只有一个元素然后将子列表合并成最终的排序列表代码示例创建临时数组复制数据到临时数组合并临时数组复制剩余元素找到中间点分别排序两半合并有序部分堆排序原理基于堆这种数据结构的一种排序方法利用堆的特性进行选择排序性能时间复杂度为不稳定排序堆排序的基本步骤建立最大堆将待排序的数组构造成一个最大堆排序将最大堆的根节点最大值与最后一个节点交换然后减少堆的大小再次调整堆为最大堆重复这个过程直到堆的大小为堆排序的实现以下是堆排序的实现构建最大堆一个个从堆顶取出元素将当前根节点移至末尾调用方法在减小的堆上调整堆为最大堆初始化最大为根左子节点右子节点如果左子节点大于根节点如果右子节点比最大值还大如果最大值不是根节点递归地构造受影响的子树在这个实现中方法用于构建和维护最大堆方法首先构建最大堆然后通过交换堆顶元素最大值与数组末尾元素并重新调整堆的大小来逐步完成整个数组的排序每种排序算法都有其优缺点适合于不同的应用场景和数据集大小在实际应用中选择合适的排序算法可以显著影响程序的性能要实现防盗门的设计我们可以使用接口和抽象类来定义防盗门的不同方面在这种情况下接口可以定义防盗门应具备的功能而抽象类则可以实现一些通用的行为和属性接口定义功能接口是一种合约它定义了防盗门应该具备的功能但不提供具体的实现例如防盗门可能需要锁定解锁和报警等功能这个接口定义了三个方法锁定门解锁门和触发警报抽象类提供基本实现抽象类可以提供一些基础功能的实现例如门的开关状态同时还可以留出一些方法让子类根据具体类型去实现抽象方法子类需要提供具体实现在这个类中我们提供了门的基本行为如开门和关门同时留下了和方法的实现给子类具体实现接下来可以创建一个具体的防盗门类实现这些方法这个类实现了接口中定义的所有方法根据需要还可以创建更多具体的防盗门类每个类都有自己的锁定解锁和报警机制使用最后可以这样使用这些类这种设计方法使得防盗门的设计灵活且可扩展同时保持了代码的整洁和易于维护性通过接口和抽象类可以方便地为防盗门添加新的功能和实现而不影响现有的代码结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-18 11:13:10',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">HK的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWD/" style="font-size: 1.05rem;">AWD<sup>1</sup></a><a href="/tags/CTF/" style="font-size: 1.05rem;">CTF<sup>1</sup></a><a href="/tags/Debug/" style="font-size: 1.05rem;">Debug<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>1</sup></a><a href="/tags/Java%E9%98%B6%E6%AE%B5%E4%B8%80/" style="font-size: 1.05rem;">Java阶段一<sup>2</sup></a><a href="/tags/NONE/" style="font-size: 1.05rem;">NONE<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>1</sup></a><a href="/tags/Python%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Python学习<sup>16</sup></a><a href="/tags/%E6%B0%B4%E6%BB%B4%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E7%8F%AD/" style="font-size: 1.05rem;">水滴逆向基础班<sup>1</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%88%AC%E8%99%AB%EF%BC%9A%E4%B8%80/" style="font-size: 1.05rem;">爬虫：一<sup>10</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.05rem;">网站<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Java考试复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-18T01:44:49.000Z" title="发表于 2023-12-18 09:44:49">2023-12-18</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-18T03:13:10.120Z" title="更新于 2023-12-18 11:13:10">2023-12-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"><header><h1 id="CrawlerTitle" itemprop="name headline">Java考试复习</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">HK</span><time itemprop="dateCreated datePublished" datetime="2023-12-18T01:44:49.000Z" title="发表于 2023-12-18 09:44:49">2023-12-18</time><time itemprop="dateCreated datePublished" datetime="2023-12-18T03:13:10.120Z" title="更新于 2023-12-18 11:13:10">2023-12-18</time></header><h3 id="1-标识符（Identifiers）"><a href="#1-标识符（Identifiers）" class="headerlink" title="1. 标识符（Identifiers）"></a>1. 标识符（Identifiers）</h3><p>标识符是在编程语言中，用于识别类、变量、方法等实体的名称。在Java中，标识符遵循以下规则：</p>
<ul>
<li><strong>字符组成</strong>：可以包含字母、数字、下划线(_)和美元符号($)。</li>
<li><strong>开头</strong>：标识符不能以数字开始。</li>
<li><strong>保留字</strong>：不能使用Java的关键字（如 <code>int</code>, <code>class</code>, <code>static</code> 等）作为标识符。</li>
<li><strong>大小写敏感</strong>：Java中的标识符是大小写敏感的，例如，<code>myVariable</code> 和 <code>MyVariable</code> 被视为不同的标识符。</li>
</ul>
<p><strong>好的实践</strong>：</p>
<ul>
<li>类名应该使用大写字母开头的驼峰式命名法（如 <code>Student</code>, <code>Employee</code>）。</li>
<li>方法和变量名应该使用小写字母开头的驼峰式命名法（如 <code>calculateTotal</code>, <code>firstName</code>）。</li>
<li>常量通常使用全大写字母，单词间以下划线分隔（如 <code>MAX_SIZE</code>, <code>DEFAULT_VALUE</code>）。</li>
</ul>
<h3 id="2-注释（Comments）"><a href="#2-注释（Comments）" class="headerlink" title="2. 注释（Comments）"></a>2. 注释（Comments）</h3><p>注释是解释代码意图和功能的非执行文本。Java中有三种类型的注释：</p>
<ul>
<li><p><strong>单行注释</strong>：使用 <code>//</code>。这种注释只影响它后面的一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算两数之和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行注释</strong>：使用 <code>/* ... */</code>。这种注释可以跨越多行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个多行注释</span></span><br><span class="line"><span class="comment">   可以用来解释代码的更多细节 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> a - b;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文档注释</strong>：使用 <code>/** ... */</code>。这种注释用于生成JavaDoc，它可以描述类、方法和字段等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算两个整数的乘积</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 第一个整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 第二个整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 乘积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-TCP编程"><a href="#3-TCP编程" class="headerlink" title="3. TCP编程"></a>3. TCP编程</h3><p>TCP（Transmission Control Protocol）是一种可靠的、面向连接的网络协议。Java中的TCP编程主要涉及<code>Socket</code>类和<code>ServerSocket</code>类。</p>
<ul>
<li><strong>Socket</strong>：在客户端，<code>Socket</code>用于建立网络连接，发送和接收数据。</li>
<li><strong>ServerSocket</strong>：在服务器端，<code>ServerSocket</code>用于监听客户端的连接请求。</li>
</ul>
<p><strong>TCP客户端示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serverHostname</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(serverHostname, serverPort);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送和接收数据</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;Hello, server!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server response: &quot;</span> + response);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TCP服务器示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(clientSocket.getOutputStream(), <span class="literal">true</span>);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(clientSocket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String inputLine;</span><br><span class="line">            <span class="keyword">while</span> ((inputLine = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                out.println(inputLine);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-线程（Threads）"><a href="#4-线程（Threads）" class="headerlink" title="4. 线程（Threads）"></a>4. 线程（Threads）</h3><p>线程是程序中的执行流。Java中的线程可以通过以下两种方式创建：</p>
<ul>
<li><strong>实现 <code>Runnable</code> 接口</strong>：这是推荐的方式，因为它允许你</li>
</ul>
<p>的类继承其他类。</p>
<ul>
<li><strong>继承 <code>Thread</code> 类</strong>：这种方式简单直接，但限制了类的继承，因为Java不支持多重继承。</li>
</ul>
<p><strong>实现 <code>Runnable</code> 接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承 <code>Thread</code> 类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from a thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">HelloThread</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在多线程环境中，同步和并发控制是关键。Java提供了多种机制（如 <code>synchronized</code> 关键字、<code>ReentrantLock</code> 类、<code>CountDownLatch</code> 类等）来帮助管理线程之间的协调和通信。</p>
<p>Java集合框架中的 <code>List</code>、<code>Set</code> 和 <code>Map</code> 是三种不同类型的集合，它们各自具有独特的特性和用途。</p>
<h3 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h3><p><code>List</code> 是一个有序集合，可以包含重复的元素。它是一个按照插入顺序排列元素的集合，你可以通过索引来访问元素。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>元素有序：元素的添加顺序决定了它们的访问顺序。</li>
<li>允许重复的元素：相同的元素可以出现多次。</li>
<li>索引访问：可以通过索引来访问或修改列表中的元素。</li>
</ul>
</li>
<li><p><strong>常见实现</strong>：</p>
<ul>
<li><code>ArrayList</code>：提供快速的随机访问和高效的基于索引的操作性能。不是线程安全的。</li>
<li><code>LinkedList</code>：除了实现 <code>List</code> 接口外，还实现了 <code>Deque</code> 接口，使其可以作为队列或双端队列使用。在列表的中间进行添加和删除操作时比 <code>ArrayList</code> 更高效。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>当需要频繁地通过索引访问元素时。</li>
<li>当需要保持元素的插入顺序时。</li>
</ul>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 允许重复</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;List: &quot;</span> + list);</span><br><span class="line">        System.out.println(<span class="string">&quot;Second element: &quot;</span> + list.get(<span class="number">1</span>)); <span class="comment">// 访问第二个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h3><p><code>Set</code> 是一个不包含重复元素的集合。它主要用于测试某个值的存在性，并确保集合中没有重复的元素。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>不允许重复的元素：添加相同元素时不会有任何效果。</li>
<li>不保证元素顺序：大多数 <code>Set</code> 实现不保证元素的顺序，甚至某些实现（如 <code>HashSet</code>）会随着时间的推移改变元素的顺序。</li>
</ul>
</li>
<li><p><strong>常见实现</strong>：</p>
<ul>
<li><code>HashSet</code>：基于哈希表实现，提供快速的添加、删除和查找操作。不保证元素的顺序。</li>
<li><code>LinkedHashSet</code>：类似于 <code>HashSet</code>，但它维护了一个链表来记录插入顺序。</li>
<li><code>TreeSet</code>：基于红黑树实现，元素按照其自然顺序或者提供的比较器进行排序。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>当需要确保集合中不出现重复元素时。</li>
<li>当元素的顺序不重要或者需要根据某种排序规则来维持元素的顺序时。</li>
</ul>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Apple&quot;</span>); <span class="comment">// 重复元素不会被添加</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Set: &quot;</span> + set); <span class="comment">// 顺序可能与添加顺序不同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h3><p><code>Map</code> 是一种键值对的集合，它通过键（key）来唯一标识元素。每个键映射到一个值（value）。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>键值对：每个元素都是一个键值对。</li>
<li>唯一的键：键不允许重复，但值可以重复。</li>
<li>不是 <code>Collection</code> 接口的一部分：<code>Map</code> 与 <code>List</code> 和 <code>Set</code> 不同，它不是 <code>Collection</code> 接口的一部分。</li>
</ul>
</li>
<li><p>**常见实</p>
</li>
</ul>
<p>现**：</p>
<ul>
<li><code>HashMap</code>：基于哈希表的 <code>Map</code> 实现，提供快速的访问和插入操作。不保证顺序。</li>
<li><code>LinkedHashMap</code>：类似于 <code>HashMap</code>，但维护了插入顺序或访问顺序。</li>
<li><code>TreeMap</code>：基于红黑树的 <code>Map</code> 实现，按照键的自然顺序或者提供的比较器进行排序。</li>
</ul>
<ul>
<li><strong>使用场景</strong>：<ul>
<li>当需要通过键来快速检索数据时。</li>
<li>当需要将值与唯一键相关联时。</li>
</ul>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">3</span>); <span class="comment">// 替换旧值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Map: &quot;</span> + map);</span><br><span class="line">        System.out.println(<span class="string">&quot;Value for &#x27;Apple&#x27;: &quot;</span> + map.get(<span class="string">&quot;Apple&quot;</span>)); <span class="comment">// 通过键访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说，<code>List</code> 用于维护有序的元素集合，<code>Set</code> 用于存储不重复的元素集合，而 <code>Map</code> 用于存储键值对，其中键是唯一的。选择哪种类型取决于具体的应用场景和需求。</p>
<h3 id="1-amp-amp-（逻辑与）"><a href="#1-amp-amp-（逻辑与）" class="headerlink" title="1. &amp;&amp;（逻辑与）"></a>1. <code>&amp;&amp;</code>（逻辑与）</h3><p><code>&amp;&amp;</code> 是逻辑与运算符，用于组合两个布尔表达式。它只有在两个布尔表达式都为 <code>true</code> 时，才返回 <code>true</code>。</p>
<ul>
<li><strong>短路特性</strong>：这是 <code>&amp;&amp;</code> 最关键的特性。如果第一个表达式的结果是 <code>false</code>，则整个表达式立即返回 <code>false</code>，而不再评估第二个表达式。这个特性在编程中非常有用，尤其是当第二个表达式依赖于第一个表达式的结果时。</li>
</ul>
<p><strong>代码示例及结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogicalAndExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>; <span class="comment">// 第一个表达式 x &gt; 10 为 false</span></span><br><span class="line">        System.out.println(result); <span class="comment">// 输出 false，第二个表达式 x &lt; 20 没有被评估</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于 <code>x &gt; 10</code> 为 <code>false</code>，<code>x &lt; 20</code> 不会被评估，整个表达式的结果直接为 <code>false</code>。</p>
<h3 id="2-amp-（按位与-非短路逻辑与）"><a href="#2-amp-（按位与-非短路逻辑与）" class="headerlink" title="2. &amp;（按位与 / 非短路逻辑与）"></a>2. <code>&amp;</code>（按位与 / 非短路逻辑与）</h3><p><code>&amp;</code> 既可以作为按位与运算符用于整数，也可以作为非短路逻辑与运算符用于布尔值。</p>
<ul>
<li><p><strong>按位与</strong>：当用于整数时，<code>&amp;</code> 对两个数的每一位进行逻辑与操作。只有两个相应的位都为1时，结果位才为1。</p>
</li>
<li><p><strong>非短路逻辑与</strong>：当用于布尔值时，它类似于 <code>&amp;&amp;</code>，但它会评估两边的表达式，即使第一个表达式为 <code>false</code>。</p>
</li>
</ul>
<p><strong>布尔逻辑的代码示例及结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitwiseAndExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> x &gt; <span class="number">10</span> &amp; x &lt; <span class="number">20</span>; <span class="comment">// x &gt; 10 为 false，但 x &lt; 20 仍然被评估</span></span><br><span class="line">        System.out.println(result); <span class="comment">// 输出 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，尽管 <code>x &gt; 10</code> 为 <code>false</code>，<code>x &lt; 20</code> 仍然被评估。但因为逻辑与操作要求两边都为 <code>true</code>，所以最终结果是 <code>false</code>。</p>
<p><strong>按位与的代码示例及结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitwiseAndExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">6</span>;  <span class="comment">// 二进制: 110</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">// 二进制: 100</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &amp; b;  <span class="comment">// 二进制: 100，即 4</span></span><br><span class="line">        System.out.println(result); <span class="comment">// 输出 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，6（二进制110）和4（二进制100）进行按位与操作，只有最右侧的位都为1，因此结果是4（二进制100）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>&amp;&amp;</code> 适用于布尔逻辑，具有短路特性，可以提高效率并防止不必要的计算或潜在的错误。</li>
<li><code>&amp;</code> 在处理整数时作为按位与运算符，在处理布尔值时作为非短路逻辑与运算符。在布尔逻辑中，它会评估两边的表达式，无论第一个表达式的结果如何。</li>
</ul>
<p>单例设计模式是一种常用的设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。单例模式在Java中广泛用于配置管理、线程池、缓存等场景。</p>
<h3 id="实现单例模式的关键要素："><a href="#实现单例模式的关键要素：" class="headerlink" title="实现单例模式的关键要素："></a>实现单例模式的关键要素：</h3><ol>
<li><strong>私有构造函数</strong>：防止通过 <code>new</code> 操作符外部直接创建类的实例。</li>
<li><strong>私有静态实例</strong>：类的唯一实例应该是私有的和静态的。</li>
<li><strong>公共静态方法</strong>：提供一个公共的静态方法来获取这个唯一实例。</li>
</ol>
<h3 id="实现单例的几种方式："><a href="#实现单例的几种方式：" class="headerlink" title="实现单例的几种方式："></a>实现单例的几种方式：</h3><h4 id="1-懒汉式（延迟实例化）"><a href="#1-懒汉式（延迟实例化）" class="headerlink" title="1. 懒汉式（延迟实例化）"></a>1. 懒汉式（延迟实例化）</h4><p>在此实现中，实例是在首次需要时创建的，这种方法是“懒加载”的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="懒汉式（Lazy-Initialization）"><a href="#懒汉式（Lazy-Initialization）" class="headerlink" title="懒汉式（Lazy Initialization）"></a>懒汉式（Lazy Initialization）</h5><p>在懒汉式实现中，单例实例在第一次被请求时创建。这种实现延迟了实例的创建，有助于节省资源和减少内存开销。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>资源利用率高，只有在实际需要时才创建实例。</li>
<li>在应用启动时减少初始化负担。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>在多线程环境下，如果没有适当的同步措施，可能会创建多个实例。</li>
<li>即使加上了同步，每次访问 <code>getInstance()</code> 方法时都需要进行同步，这会增加访问开销。<br>这种实现的缺点是，在多线程环境下可能会创建多个实例，除非 <code>getInstance</code> 方法是同步的，但这会降低性能。</li>
</ul>
<h4 id="2-饿汉式（立即实例化）"><a href="#2-饿汉式（立即实例化）" class="headerlink" title="2. 饿汉式（立即实例化）"></a>2. 饿汉式（立即实例化）</h4><p>在此实现中，实例在类被加载时立即创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式实现简单，但是它不是懒加载，可能会增加内存的使用。</p>
<h5 id="饿汉式（Eager-Initialization）"><a href="#饿汉式（Eager-Initialization）" class="headerlink" title="饿汉式（Eager Initialization）"></a>饿汉式（Eager Initialization）</h5><p>在饿汉式实现中，单例实例在类加载时立即创建。Java保证静态变量会在类首次被加载到内存时初始化，这利用了JVM本身的机制，保证了线程安全。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>线程安全，无需额外的同步措施。</li>
<li>实现简单。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>类加载时就创建实例，即使客户端可能尚未用到它，增加了内存开销。</li>
<li>没有实现懒加载（lazy loading），可能导致资源利用效率低下。</li>
</ul>
<h4 id="3-双重检查锁定（Double-Checked-Locking）"><a href="#3-双重检查锁定（Double-Checked-Locking）" class="headerlink" title="3. 双重检查锁定（Double-Checked Locking）"></a>3. 双重检查锁定（Double-Checked Locking）</h4><p>此方法结合了懒汉式和饿汉式的优点。它在同步代码块内外都进行了检查，以减少不必要的同步开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckedLockingSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckedLockingSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckedLockingSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedLockingSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLockingSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleCheckedLockingSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在多线程环境下既能保持高性能，又能保证单例。</p>
<h5 id="双重检查锁定（Double-Checked-Locking）"><a href="#双重检查锁定（Double-Checked-Locking）" class="headerlink" title="双重检查锁定（Double-Checked Locking）"></a>双重检查锁定（Double-Checked Locking）</h5><p>这种实现在 <code>getInstance()</code> 方法中两次检查实例是否已创建，并且使用同步块。这种方法既保证了懒加载，又保证了线程安全，同时减少了同步开销。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>线程安全。</li>
<li>只有在实例未被创建时才进行同步，一旦实例被创建，就无需再进行同步，减少了开销。</li>
<li>实现了懒加载。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>实现相对复杂。</li>
<li>在某些情况下可能会失效（在某些编译器和处理器上）。</li>
</ul>
<h4 id="4-静态内部类（Static-Nested-Class）"><a href="#4-静态内部类（Static-Nested-Class）" class="headerlink" title="4. 静态内部类（Static Nested Class）"></a>4. 静态内部类（Static Nested Class）</h4><p>利用静态内部类的特性，结合懒加载和线程安全的优点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClassSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StaticInnerClassSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticInnerClassSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态内部类的方式在 <code>Singleton</code> 类被加载时不会立即实例化，而是在需要实例时，调用 <code>getInstance()</code> 方法，从而完成实例化。</p>
<h5 id="静态内部类（Static-Nested-Class）"><a href="#静态内部类（Static-Nested-Class）" class="headerlink" title="静态内部类（Static Nested Class）"></a>静态内部类（Static Nested Class）</h5><p>这种方法利用了Java的类加载机制来保证实例的唯一性和线程安全。静态内部类只有在被引用时才会被加载，从而实现懒加载。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>线程安全。</li>
<li>实现懒加载。</li>
<li>无需同步，性能好。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>实现稍微复杂一些。</li>
</ul>
<h4 id="5-枚举方式（Enum-Singleton）"><a href="#5-枚举方式（Enum-Singleton）" class="headerlink" title="5. 枚举方式（Enum Singleton）"></a>5. 枚举方式（Enum Singleton）</h4><p>这是实现单例的最佳方法之一。它自动支持序列化机制，并且由JVM保证只会实例化一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>EnumSingleton.INSTANCE</code> 来访问实例，这种方法是线程安全的，并且在多线程环境下它也保持单一实例。</p>
<h5 id="枚举方式（Enum-Singleton）"><a href="#枚举方式（Enum-Singleton）" class="headerlink" title="枚举方式（Enum Singleton）"></a>枚举方式（Enum Singleton）</h5><p>使用枚举来实现单例是最简洁的方式，它自然地提供序列化机制，并由JVM保证只会实例化一次。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易懂。</li>
<li>线程安全。</li>
<li>提供序列化机制。</li>
<li>JVM保证只实例化一次。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不是懒加载（但实际上，由于枚举类的特性，这通常不是问题）。<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
<p>选择哪种实现方式取决于应用的需求。如果应用程序始终在创建和运行单例对象，则可以选择饿汉式实现；如果单例对象的创建和运行开销大，且应用程序不一定需要单例对象，则应选择懒汉式实现。双重检查锁定和静态内部类方式提供了一</p>
<p>种在需要时创建单例且保证线程安全的方式。枚举方式提供了简洁和自动支持序列化的实现。<br>选择哪种单例实现取决于具体场景：</p>
<ul>
<li>如果单例对象占用资源较少，且确定会在应用中使用，可以选择饿汉式。</li>
<li>如果资源利用是一个考虑因素，并且对同步性能要求较高，可以使用双重检查锁定或静态内部类。</li>
<li>如果希望实现简洁，且需要序列化机制，枚举方式是一个不错的选择。</li>
</ul>
<p>在考虑实现时，还需要考虑实例的创建是否会影响应用程序的启动时间，以及资源的有效利用。</p>
<p>在Java中，重载（Overloading）和重写（Overriding）是面向对象编程的两个基本概念。它们虽然听起来相似，但实际上在功能和用途上有很大的不同。</p>
<h3 id="重载（Overloading）"><a href="#重载（Overloading）" class="headerlink" title="重载（Overloading）"></a>重载（Overloading）</h3><p>重载发生在同一个类中，它指的是在一个类里面有多个同名方法，但这些方法的参数列表不同。</p>
<ul>
<li><p><strong>参数列表必须不同</strong>：重载的方法必须改变参数列表，这可以是：</p>
<ul>
<li>参数的数量不同。</li>
<li>参数的类型不同。</li>
<li>参数的顺序不同（如果类型不同）。</li>
</ul>
</li>
<li><p><strong>返回类型可以不同</strong>：重载的方法可以有不同的返回类型，但仅仅改变返回类型不足以构成重载。</p>
</li>
<li><p><strong>访问修饰符和异常可以不同</strong>：重载的方法可以有不同的访问修饰符和抛出的异常。</p>
</li>
<li><p><strong>编译时的行为</strong>：编译器根据方法签名（方法名称加参数列表）来决定调用哪个重载的方法。</p>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数类型不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量和类型都不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>add</code> 方法被重载了三次，每次都有不同的参数列表。</p>
<h3 id="重写（Overriding）"><a href="#重写（Overriding）" class="headerlink" title="重写（Overriding）"></a>重写（Overriding）</h3><p>重写发生在父类和子类之间。当子类有一个方法与父类的某个方法具有相同的名称和参数列表时，子类的方法会重写（或覆盖）父类的方法。</p>
<ul>
<li><p><strong>方法名称和参数列表必须完全相同</strong>：也就是说，子类中的方法和父类中被重写的方法必须有相同的方法签名。</p>
</li>
<li><p><strong>返回类型必须相同或是子类型</strong>：从Java 5开始，允许子类重写的方法返回父类方法返回类型的子类型。</p>
</li>
<li><p><strong>访问级别不能更严格</strong>：子类的方法不能有比父类方法更严格的访问级别。</p>
</li>
<li><p><strong>抛出的异常应该相同或是异常的子类型</strong>：如果有的话。</p>
</li>
<li><p><strong>运行时决定</strong>：哪个重写方法应该被调用是在运行时基于对象的实际类型决定的。</p>
</li>
<li><p><strong>使用 <code>@Override</code> 注解</strong>：这个注解不是必需的，但建议使用，因为它可以帮助编译器检测到子类是否正确地重写了父类方法。</p>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Display in Parent Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Display in Child Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParentClass</span>();</span><br><span class="line">        obj1.display(); <span class="comment">// 输出: Display in Parent Class</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        obj2.display(); <span class="comment">// 输出: Display in Child Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>ChildClass</code> 重写了 <code>ParentClass</code> 中的 <code>display</code> 方法。当使用 <code>ChildClass</code> 的实例调用 <code>display</code> 方法时，将执行重写后的版本。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>重载（Overloading）</strong> 主要关注于同一个类内部多个同名方法的参数不同，是编译时的概念。</li>
<li><strong>重写（Overriding）</strong> 关注于子类如何具体实现或修改父类的某个方法，是运行时的概念。</li>
</ul>
<h3 id="抽象类（Abstract-Class）"><a href="#抽象类（Abstract-Class）" class="headerlink" title="抽象类（Abstract Class）"></a>抽象类（Abstract Class）</h3><p>抽象类是一种特殊的类，不能被直接实例化。它通常被用作其他类的基类（父类）。抽象类的主要特点和用途包括：</p>
<ul>
<li><p><strong>部分实现与抽象方法</strong>：抽象类可以包含完全实现的方法（具体方法）和没有实现的方法（抽象方法）。子类继承抽象类时，必须实现所有的抽象方法，除非它们也被声明为抽象类。</p>
</li>
<li><p><strong>状态保持</strong>：抽象类可以有成员变量，用于保存状态信息。这些成员变量可以是非静态的，因此可以在对象实例中具有唯一的状态。</p>
</li>
<li><p><strong>构造函数</strong>：抽象类可以有构造函数，尽管抽象类不能直接实例化。这些构造函数可以被子类调用来初始化子类对象的共同属性或行为。</p>
</li>
<li><p><strong>限制继承</strong>：由于Java不支持多重类继承，因此一个类只能继承一个抽象类。这可以被视为既是一个优点（有助于维持类的层次结构）也是一个限制（不如接口灵活）。</p>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Color: &quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>接口定义了一组方法，这些方法可以被任何实现了该接口的类所实现。接口的主要特点和用途包括：</p>
<ul>
<li><p><strong>全抽象的方法</strong>（Java 8之前）：在Java 8之前，接口只能有抽象方法（没有方法体的方法）。这意味着实现接口的任何类都必须实现这些方法。</p>
</li>
<li><p><strong>默认方法</strong>（Java 8及之后）：Java 8引入了接口的默认方法，这些方法有一个默认的实现。这使得接口变得更加灵活，因为不是所有实现该接口的类都必须实现这些方法。</p>
</li>
<li><p><strong>多重实现</strong>：一个类可以实现多个接口，这提供了一种形式的多重继承。这意味着类可以拥有多个不相关类的行为。</p>
</li>
<li><p><strong>静态方法和常量</strong>：接口可以包含静态方法和常量。常量默认是 <code>public static final</code> 的，而静态方法可以有自己的实现。</p>
</li>
<li><p><strong>无状态</strong>：接口不能有实例变量，它们可以有静态变量，但这些变量必须是常量（final）。</p>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Drawable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 默认方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Showing drawable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>抽象类</strong> 用于创建一个含有一些实现和一些需要由子类实现的方法的类框架。它适用于多个类共享一些共同的方法实现或属性时。</p>
</li>
<li><p><strong>接口</strong> 用于定义一个可以被多个类实现的契约。接口更加灵活，特别是在需要多重继承的功能特性时。</p>
</li>
</ul>
<p>在实际应用中，选择抽象类还是接口通常取决于你要设计的系统的具体需求。随着Java的发展，接口越来越强大，提供了更多灵活性，但抽象类仍然在某些特定情况下非常有用。</p>
<p>在Java中，<code>this</code> 关键字是一个引用变量，指向当前对象。当你在一个方法或构造器内部使用 <code>this</code>，你实际上是在引用当前对象的成员。</p>
<p>在 <code>this.color = color;</code> 这行代码中，这个语句出现在类的构造函数中，其作用是将传递给构造函数的参数 <code>color</code> 的值赋值给类的成员变量 <code>color</code>。这里需要使用 <code>this</code> 关键字来区分成员变量和参数，因为它们的名称是相同的。</p>
<p>让我更详细地解释一下：</p>
<h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ul>
<li><p><strong>成员变量</strong>：定义在类中的变量，它们是对象的属性或状态的一部分。在这个例子中，<code>color</code> 是一个成员变量。</p>
</li>
<li><p><strong>局部变量</strong>：定义在方法、构造器或代码块中的变量。在这个例子中，构造器的参数 <code>color</code> 是一个局部变量。</p>
</li>
</ul>
<h3 id="使用-this-关键字"><a href="#使用-this-关键字" class="headerlink" title="使用 this 关键字"></a>使用 <code>this</code> 关键字</h3><ul>
<li><p>当一个局部变量（如方法或构造器的参数）和一个成员变量具有相同的名称时，为了区分这两个变量，我们使用 <code>this</code> 关键字。<code>this</code> 关键字引用的是当前对象，它的成员变量。</p>
</li>
<li><p>在 <code>this.color = color;</code> 这个赋值语句中：</p>
<ul>
<li><code>this.color</code> 指的是当前对象的成员变量 <code>color</code>。</li>
<li>等号右边的 <code>color</code> 指的是传递给构造器的参数。</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123; <span class="comment">// 构造器的参数也叫 color</span></span><br><span class="line">        <span class="built_in">this</span>.color = color; <span class="comment">// 将成员变量 color 设置为参数 color 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，构造函数 <code>Shape(String color)</code> 接收一个参数 <code>color</code>。由于成员变量也被命名为 <code>color</code>，因此使用 <code>this.color</code> 来明确我们指的是成员变量，而非参数。</p>
<p>这种做法在Java中非常普遍，它清楚地表明了哪个 <code>color</code> 是类的属性（成员变量），哪个是仅在构造器或方法中使用的局部变量或参数。</p>
<p>在Java中，字符流和字节流是处理输入和输出（I/O）的两种主要方式，它们在处理数据时有着本质的区别。</p>
<h3 id="字节流（Byte-Streams）"><a href="#字节流（Byte-Streams）" class="headerlink" title="字节流（Byte Streams）"></a>字节流（Byte Streams）</h3><p>字节流主要用于处理原始二进制数据。它们读写数据的基本单位是字节（8位），因此非常适合处理所有类型的数据，如图像、视频、音频、二进制文件等。</p>
<ul>
<li><strong>基本类</strong>：字节流的基本类是 <code>InputStream</code> 和 <code>OutputStream</code>。</li>
<li><strong>用途</strong>：字节流非常适合处理非文本文件，如二进制文件和媒体文件。</li>
<li><strong>操作方式</strong>：在字节流中，所有的数据都是按字节来处理的。</li>
</ul>
<p><strong>示例</strong>：使用字节流读取文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.dat&quot;</span>);</span><br><span class="line">        <span class="type">int</span> byteRead;</span><br><span class="line">        <span class="keyword">while</span> ((byteRead = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理读取的字节</span></span><br><span class="line">        &#125;</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符流（Character-Streams）"><a href="#字符流（Character-Streams）" class="headerlink" title="字符流（Character Streams）"></a>字符流（Character Streams）</h3><p>字符流用于处理文本数据。它们按字符读写数据，一个字符可能占用一个或多个字节（取决于字符编码）。字符流自动处理字符编码的转换过程，这使得它们非常适合处理文本文件。</p>
<ul>
<li><strong>基本类</strong>：字符流的基本类是 <code>Reader</code> 和 <code>Writer</code>。</li>
<li><strong>用途</strong>：字符流主要用于处理文本数据。由于它们处理字符编码，因此特别适合处理多字节的字符集，如UTF-8。</li>
<li><strong>操作方式</strong>：字符流在内部自动处理字节到字符的转换。当你从输入流读取数据时，字符流自动将字节组装成字符；当你写入数据时，字符流将字符拆分成字节。</li>
</ul>
<p><strong>示例</strong>：使用字符流读取文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStreamExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> charRead;</span><br><span class="line">        <span class="keyword">while</span> ((charRead = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>字节流</strong> 是处理原始二进制数据的低级流，适合所有类型的数据，尤其是非文本数据。</li>
<li><strong>字符流</strong> 是处理字符数据的高级流，自动处理字符编码问题，适合处理文本数据。</li>
</ul>
<p>在实际应用中，选择字节流还是字符流取决于你要处理的数据类型。如果你处理的是文本数据，建议使用字符流；如果处理的是二进制数据，如图像或视频文件，则应使用字节流。</p>
<p>对象序列化是Java编程中的一个核心概念，涉及到将对象的状态转换成可以存储或传输的格式的过程。在Java中，这通常意味着将对象转换成字节流，以便可以将其写入磁盘，通过网络发送，或在其他地方使用。</p>
<h3 id="什么是对象序列化"><a href="#什么是对象序列化" class="headerlink" title="什么是对象序列化"></a>什么是对象序列化</h3><ul>
<li><p><strong>对象转换为字节流</strong>：序列化是将对象的状态信息转换为可以存储或传输的形式（如文件或内存缓冲区中的字节流）的过程。序列化后的数据可以在需要的时候被反序列化成原始对象。</p>
</li>
<li><p><strong>数据存储和通信</strong>：序列化使得对象的数据可以轻松地保存到文件中或在网络上传输，并且稍后可以完整地重建对象。</p>
</li>
</ul>
<h3 id="如何实现序列化"><a href="#如何实现序列化" class="headerlink" title="如何实现序列化"></a>如何实现序列化</h3><p>在Java中，要实现对象的序列化，通常需要做以下几步：</p>
<ol>
<li><p><strong>实现 <code>Serializable</code> 接口</strong>：让一个类实现 <code>java.io.Serializable</code> 接口。这个接口是一个标记接口，没有方法需要实现，它告诉Java虚拟机这个类的对象可以被序列化。</p>
</li>
<li><p><strong>使用 <code>ObjectOutputStream</code></strong>：利用 <code>java.io.ObjectOutputStream</code> 类将对象写入流中。<code>ObjectOutputStream</code> 可以将对象转换为字节流。</p>
</li>
<li><p><strong>反序列化</strong>：使用 <code>java.io.ObjectInputStream</code> 类从流中重构对象。这一过程称为反序列化。</p>
</li>
</ol>
<h4 id="示例代码：序列化和反序列化"><a href="#示例代码：序列化和反序列化" class="headerlink" title="示例代码：序列化和反序列化"></a>示例代码：序列化和反序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的可序列化类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// 使用 transient 关键字标记的字段不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">            out.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>))) &#123;</span><br><span class="line">            deserializedUser = (User) in.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(deserializedUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>User</code> 类实现了 <code>Serializable</code> 接口，使得其对象可以被序列化和反序列化。<code>transient</code> 关键字用于指示不希望某个字段被序列化。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>版本控制</strong>：通过声明 <code>serialVersionUID</code> 字段来控制序列化版本，这有助于在反序列化时确保类版本的兼容性。</li>
<li><strong>安全性</strong>：对象序列化可能存在安全风险，因为攻击者可能会修改序列化数据来攻击系统。因此，当处理不信任的数据时，应该谨慎使用序列化。</li>
<li><strong>性能</strong>：序列化和反序列化过程涉及到复杂的转换，可能会对性能有所影响，尤其是在大对象或大量数据的情况下。因此，应该尽可能地减少序列化数据的体积和数量，以提高性能。</li>
</ul>
<p>冒泡排序是最基本的排序算法之一，它的工作原理是通过重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行的，直到没有再需要交换，也就是说该数列已经排序完成。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>算法步骤</strong>：</p>
<ol>
<li>比较相邻的两个元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。完成一遍后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换 arr[j+1] 和 arr[j]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他常见排序算法"><a href="#其他常见排序算法" class="headerlink" title="其他常见排序算法"></a>其他常见排序算法</h3><h4 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h4><ul>
<li><strong>原理</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li><strong>性能</strong>：时间复杂度为 O(n^2)，不稳定排序。</li>
</ul>
<p>选择排序的基本思想是在每次迭代中找到最小（或最大）元素，并将其放置到序列的起始位置。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                    minIndex = j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换找到的最小元素和第i个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[minIndex];</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h4><ul>
<li><strong>原理</strong>：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
<li><strong>性能</strong>：时间复杂度为 O(n^2)，稳定排序。<br>插入排序工作方式是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将大于key的元素向后移动一个位置 */</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h4><ul>
<li><strong>原理</strong>：选择一个基准元素，分区过程将其它所有元素分为两个分区，将比基准值小的元素移到基准前，大的移到后面。</li>
<li><strong>性能</strong>：平均时间复杂度为 O(n log n)，不稳定排序。<br>快速排序使用分治法策略来把一个序列分为较小和较大的两个子序列，然后递归地排序两个子序列。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (low - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换 arr[i+1] 和 arr[high] (或 pivot)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pi</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归地排序分区的元素</span></span><br><span class="line">            quickSort(arr, low, pi - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pi + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h4><ul>
<li><strong>原理</strong>：采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</li>
<li><strong>性能</strong>：时间复杂度为 O(n log n)，稳定排序。<br>归并排序是一种分治算法。它不断地将列表分成两半，直到每个子列表只有一个元素，然后将子列表合并成最终的排序列表。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> m - l + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> r - m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建临时数组</span></span><br><span class="line">        <span class="type">int</span>[] L = <span class="keyword">new</span> <span class="title class_">int</span>[n1];</span><br><span class="line">        <span class="type">int</span>[] R = <span class="keyword">new</span> <span class="title class_">int</span>[n2];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制数据到临时数组</span></span><br><span class="line">        System.arraycopy(arr, l, L, <span class="number">0</span>, n1);</span><br><span class="line">        System.arraycopy(arr, m + <span class="number">1</span>, R, <span class="number">0</span>, n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并临时数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">                arr[k] = L[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = R[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制剩余元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">            arr[k] = L[i</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 找到中间点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分别排序两半</span></span><br><span class="line">            mergeSort(arr, l, m);</span><br><span class="line">            mergeSort(arr, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并有序部分</span></span><br><span class="line">            merge(arr, l, m, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h4><ul>
<li><strong>原理</strong>：基于堆这种数据结构的一种排序方法。利用堆的特性进行选择排序。</li>
<li><strong>性能</strong>：时间复杂度为 O(n log n)，不稳定排序。</li>
</ul>
<p>堆排序的基本步骤：</p>
<ol>
<li><strong>建立最大堆</strong>：将待排序的数组构造成一个最大堆。</li>
<li><strong>排序</strong>：将最大堆的根节点（最大值）与最后一个节点交换，然后减少堆的大小，再次调整堆为最大堆。重复这个过程直到堆的大小为1。</li>
</ol>
<p>堆排序的实现</p>
<p>以下是堆排序的Java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个个从堆顶取出元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 将当前根节点移至末尾</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 max heapify 方法在减小的堆上</span></span><br><span class="line">            heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整堆为最大堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i; <span class="comment">// 初始化最大为根</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子节点大于根节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])</span><br><span class="line">            largest = l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果右子节点比最大值还大</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])</span><br><span class="line">            largest = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最大值不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[largest];</span><br><span class="line">            arr[largest] = swap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归地构造受影响的子树</span></span><br><span class="line">            heapify(arr, n, largest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个实现中，<code>heapify</code> 方法用于构建和维护最大堆。<code>sort</code> 方法首先构建最大堆，然后通过交换堆顶元素（最大值）与数组末尾元素并重新调整堆的大小，来逐步完成整个数组的排序。</p>
<p>每种排序算法都有其优缺点，适合于不同的应用场景和数据集大小。在实际应用中，选择合适的排序算法可以显著影响程序的性能。</p>
<p>要实现防盗门的设计，我们可以使用接口和抽象类来定义防盗门的不同方面。在这种情况下，接口可以定义防盗门应具备的功能，而抽象类则可以实现一些通用的行为和属性。</p>
<h3 id="接口-定义功能"><a href="#接口-定义功能" class="headerlink" title="接口 - 定义功能"></a>接口 - 定义功能</h3><p>接口是一种合约，它定义了防盗门应该具备的功能，但不提供具体的实现。例如，防盗门可能需要锁定、解锁和报警等功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheftDoor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">alarm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>AntiTheftDoor</code> 接口定义了三个方法：<code>lock()</code>（锁定门）、<code>unlock()</code>（解锁门）和 <code>alarm()</code>（触发警报）。</p>
<h3 id="抽象类-提供基本实现"><a href="#抽象类-提供基本实现" class="headerlink" title="抽象类 - 提供基本实现"></a>抽象类 - 提供基本实现</h3><p>抽象类可以提供一些基础功能的实现，例如门的开关状态，同时还可以留出一些方法让子类根据具体类型去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheftDoor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOpen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isOpen = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) &#123;</span><br><span class="line">            isOpen = <span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Door opened.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">            isOpen = <span class="literal">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Door closed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，子类需要提供具体实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">alarm</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个 <code>AbstractDoor</code> 类中，我们提供了门的基本行为（如开门和关门），同时留下了 <code>lock</code>、<code>unlock</code> 和 <code>alarm</code> 方法的实现给子类。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>接下来，可以创建一个具体的防盗门类，实现这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicAntiTheftDoor</span> <span class="keyword">extends</span> <span class="title class_">AbstractDoor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Door locked with basic lock.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Door unlocked with basic key.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alarm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Basic alarm activated.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>BasicAntiTheftDoor</code> 类实现了接口中定义的所有方法。根据需要，还可以创建更多具体的防盗门类，每个类都有自己的锁定、解锁和报警机制。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>最后，可以这样使用这些类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AntiTheftDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicAntiTheftDoor</span>();</span><br><span class="line">        door.lock();</span><br><span class="line">        door.alarm();</span><br><span class="line">        door.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种设计方法使得防盗门的设计灵活且可扩展，同时保持了代码的整洁和易于维护性。通过接口和抽象类，可以方便地为防盗门添加新的功能和实现，而不影响现有的代码结构。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">HK</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/')">Java考试复习</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java考试复习&amp;url=http://example.com/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HK的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java学习笔记-2</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/22/EnglishsReview/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">EnglishsReview</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Identifiers%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. 标识符（Identifiers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B3%A8%E9%87%8A%EF%BC%88Comments%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 注释（Comments）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3. TCP编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%EF%BC%88Threads%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. 线程（Threads）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-List"><span class="toc-number">5.</span> <span class="toc-text">1. List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Set"><span class="toc-number">6.</span> <span class="toc-text">2. Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Map"><span class="toc-number">7.</span> <span class="toc-text">3. Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-amp-amp-%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">1. &amp;&amp;（逻辑与）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-amp-%EF%BC%88%E6%8C%89%E4%BD%8D%E4%B8%8E-%E9%9D%9E%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E4%B8%8E%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">2. &amp;（按位与 &#x2F; 非短路逻辑与）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E9%94%AE%E8%A6%81%E7%B4%A0%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">实现单例模式的关键要素：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">实现单例的几种方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">1. 懒汉式（延迟实例化）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88Lazy-Initialization%EF%BC%89"><span class="toc-number">12.1.1.</span> <span class="toc-text">懒汉式（Lazy Initialization）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E7%AB%8B%E5%8D%B3%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">2. 饿汉式（立即实例化）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88Eager-Initialization%EF%BC%89"><span class="toc-number">12.2.1.</span> <span class="toc-text">饿汉式（Eager Initialization）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%EF%BC%88Double-Checked-Locking%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">3. 双重检查锁定（Double-Checked Locking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%EF%BC%88Double-Checked-Locking%EF%BC%89"><span class="toc-number">12.3.1.</span> <span class="toc-text">双重检查锁定（Double-Checked Locking）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static-Nested-Class%EF%BC%89"><span class="toc-number">12.4.</span> <span class="toc-text">4. 静态内部类（Static Nested Class）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static-Nested-Class%EF%BC%89"><span class="toc-number">12.4.1.</span> <span class="toc-text">静态内部类（Static Nested Class）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9E%9A%E4%B8%BE%E6%96%B9%E5%BC%8F%EF%BC%88Enum-Singleton%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">5. 枚举方式（Enum Singleton）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E6%96%B9%E5%BC%8F%EF%BC%88Enum-Singleton%EF%BC%89"><span class="toc-number">12.5.1.</span> <span class="toc-text">枚举方式（Enum Singleton）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">13.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overloading%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">重载（Overloading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Overriding%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">重写（Overriding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">16.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88Abstract-Class%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">抽象类（Abstract Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88Interface%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">接口（Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">19.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">20.</span> <span class="toc-text">成员变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.</span> <span class="toc-text">使用 this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">22.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88Byte-Streams%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">字节流（Byte Streams）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%88Character-Streams%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">字符流（Character Streams）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">25.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">26.</span> <span class="toc-text">什么是对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">27.</span> <span class="toc-text">如何实现序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">27.1.</span> <span class="toc-text">示例代码：序列化和反序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">28.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">29.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">其他常见排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">30.1.</span> <span class="toc-text">选择排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">30.2.</span> <span class="toc-text">插入排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">30.3.</span> <span class="toc-text">快速排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">30.4.</span> <span class="toc-text">归并排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">30.5.</span> <span class="toc-text">堆排序：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD"><span class="toc-number">31.</span> <span class="toc-text">接口 - 定义功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8F%90%E4%BE%9B%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">32.</span> <span class="toc-text">抽象类 - 提供基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">33.</span> <span class="toc-text">具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">34.</span> <span class="toc-text">使用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/24/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0/" title="离散数学复习">离散数学复习</a><time datetime="2023-12-24T11:25:44.000Z" title="发表于 2023-12-24 19:25:44">2023-12-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/22/EnglishsReview/" title="EnglishsReview">EnglishsReview</a><time datetime="2023-12-21T16:09:53.000Z" title="发表于 2023-12-22 00:09:53">2023-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/18/Java%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="Java考试复习">Java考试复习</a><time datetime="2023-12-18T01:44:49.000Z" title="发表于 2023-12-18 09:44:49">2023-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/11/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/" title="Java学习笔记-2">Java学习笔记-2</a><time datetime="2023-12-11T02:34:33.000Z" title="发表于 2023-12-11 10:34:33">2023-12-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" title="Java学习笔记-1">Java学习笔记-1</a><time datetime="2023-12-04T01:48:36.000Z" title="发表于 2023-12-04 09:48:36">2023-12-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="HK" target="_blank">HK</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AWD/" style="font-size: 0.88rem;">AWD<sup>1</sup></a><a href="/tags/CTF/" style="font-size: 0.88rem;">CTF<sup>1</sup></a><a href="/tags/Debug/" style="font-size: 0.88rem;">Debug<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>1</sup></a><a href="/tags/Java%E9%98%B6%E6%AE%B5%E4%B8%80/" style="font-size: 0.88rem;">Java阶段一<sup>2</sup></a><a href="/tags/NONE/" style="font-size: 0.88rem;">NONE<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Python%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Python学习<sup>16</sup></a><a href="/tags/%E6%B0%B4%E6%BB%B4%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%E7%8F%AD/" style="font-size: 0.88rem;">水滴逆向基础班<sup>1</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%88%AC%E8%99%AB%EF%BC%9A%E4%B8%80/" style="font-size: 0.88rem;">爬虫：一<sup>10</sup></a><a href="/tags/%E7%BD%91%E7%AB%99/" style="font-size: 0.88rem;">网站<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 HK 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>